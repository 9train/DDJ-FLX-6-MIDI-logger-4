<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FLX6 Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="./styles.css" />

  <!-- SOP: viewer-only UI trim (host unaffected by CSS below) -->
  <style>
    /* Viewer: hide only Rec + Save; keep Stop/Play/Load visible */
    body.viewer #recStart,
    body.viewer #recSave {
      display: none !important;
    }
    /* Viewer: hide any host panels/menus if something tried to show them */
    body.viewer .panel,
    body.viewer [data-panel],
    body.viewer .edit-toolbar,
    body.viewer .wizard,
    body.viewer .diagnostics,
    body.viewer .timeline {
      display: none !important;
    }
  </style>
</head>
<body>
  <!-- Top toolbar (you can hide this in OBS if you prefer) -->
  <div id="ui">
    <div class="left" style="display:flex;gap:8px;align-items:center;">
      <button id="fit" title="Fit SVG inside window">Fit</button>
      <button id="fill" title="Fill the frame (good for OBS)">Fill</button>
      <button id="toggleBG" title="Toggle transparent background">Toggle BG</button>
    </div>
    <div class="right" style="display:flex;gap:10px;align-items:center;">
      <span id="wsStatus">WS: ⏳</span>
      <span id="midiStatus">MIDI: ⏳</span>
      <div id="presetMount" style="display:flex;gap:8px;align-items:center;"></div>

      <!-- Recorder controls -->
      <button id="recStart" title="Start recording incoming MIDI">Rec</button>
      <button id="recStop"  title="Stop recording">Stop</button>
      <button id="recPlay"  title="Play last recording">Play</button>
      <button id="recSave"  title="Download as JSON">Save</button>
      <label style="display:inline-flex;align-items:center;gap:6px;">
        Load
        <input id="recLoad" type="file" accept="application/json" style="width:150px;" />
      </label>
    </div>
  </div>

  <!-- Stage for the SVG board -->
  <section id="boardHost" aria-label="Controller visual"></section>

  <!-- Global default WS endpoint (viewers never send) -->
  <script>
    window.WS_URL = window.WS_URL || "wss://ws.setsoutofcontext.com";
  </script>

  <!-- App wiring -->
  <script type="module">
    /****************************************************************
     * Imports (keep core static; load host-only stuff later)
     ****************************************************************/
    import { initBoard, consumeInfo as boardConsume, getUnifiedMap } from '/src/board.js';
    import { connectWS }   from '/src/ws.js';
    import * as THEME from '/src/theme.js';

    /****************************************************************
     * Role + WS URL resolution (prefer roles.js if present)
     ****************************************************************/
    let roleResolved = null;
    let urlResolved  = null;

    try {
      const mod = await import('/src/roles.js');
      if (mod?.getRole && mod?.getWSURL) {
        roleResolved = mod.getRole();
        urlResolved  = mod.getWSURL();
      }
    } catch { /* optional */ }

    const qs    = new URLSearchParams(location.search);
    const host  = location.hostname || 'localhost';
    const wsURL_fallback = qs.get('ws') || `ws://${host}:` + (qs.get('wsport') || '8787');
    const role  = roleResolved || (qs.get('role') === 'host' ? 'host' : 'viewer');
    const wsURL = urlResolved  || window.WS_URL || wsURL_fallback;

    // Expose role and tag <body> for CSS
    window.FLX_ROLE = role;
    document.body.classList.add(role);
    document.body.dataset.role = role;

    /****************************************************************
     * Init: board + Theme
     ****************************************************************/
    await initBoard({ hostId: 'boardHost' });
    THEME.attachThemeDesigner({ svgRoot: document.querySelector('#boardHost svg') });
    // Shift+T to toggle Theme

    /****************************************************************
     * Unified consumer
     ****************************************************************/
    const baseConsume = (info) => boardConsume(info);
    window.consumeInfo = baseConsume;

    /****************************************************************
     * Status helpers (+ legacy #status mirror if present)
     ****************************************************************/
    const wsStatusEl   = document.getElementById('wsStatus');
    const midiStatusEl = document.getElementById('midiStatus');
    const setWSStatus   = (s) => { if (wsStatusEl)   wsStatusEl.textContent   = 'WS: '   + s; };
    const setMIDIStatus = (s) => { if (midiStatusEl) midiStatusEl.textContent = 'MIDI: ' + s; };
    const legacyStatus  = document.getElementById('status');
    const mirrorLegacy  = () => { if (legacyStatus && wsStatusEl) legacyStatus.textContent = wsStatusEl.textContent; };

    /****************************************************************
     * Host: ensure recorder installed BEFORE WS/WebMIDI (preserve behavior)
     ****************************************************************/
    let FLXRec, RECUI;
    if (role === 'host') {
      try {
        ({ recorder: FLXRec } = await import('/src/recorder.js'));
        // Preserve original behavior: recorder installs early to catch events
        FLXRec.install?.();
      } catch {}
    }

    /****************************************************************
     * WebSocket
     ****************************************************************/
    const wsClient = connectWS({
      url: wsURL,
      role,
      onInfo: (info) => window.consumeInfo(info),
      onStatus: (s) => { setWSStatus(s); mirrorLegacy(); },
    });
    window.wsClient = wsClient;

    /****************************************************************
     * Host: forward every local event to server
     ****************************************************************/
    if (role === 'host') {
      const origConsume = window.consumeInfo;
      window.consumeInfo = (info) => {
        if (wsClient?.isAlive?.()) wsClient.send(info);
        return origConsume(info);
      };
    } else {
      // Viewer doesn’t use WebMIDI
      setMIDIStatus('viewer');
    }

    /****************************************************************
     * Host: push learned map to viewers
     ****************************************************************/
    if (role === 'host') {
      try {
        const { loadMappings } = await import('/src/mapper.js');
        const pushMap = () => {
          try {
            const mapArray = loadMappings() || [];
            if (wsClient?.sendMap) wsClient.sendMap(mapArray);
            else if (wsClient?.send) wsClient.send({ type: 'map_sync', payload: mapArray });
          } catch {}
        };
        setTimeout(pushMap, 250);
        window.addEventListener('flx:map-updated', pushMap);
      } catch {}
    }

    /****************************************************************
     * WebMIDI (host only)
     ****************************************************************/
    if (role === 'host') {
      try {
        const { initWebMIDI } = await import('/src/midi.js');
        const preferred = qs.get('midi') || 'DDJ-FLX6';
        await initWebMIDI({
          onInfo: (info) => window.consumeInfo(info),
          preferredInput: preferred,
          onStatus: (s) => setMIDIStatus(s),
          log: qs.has('logmidi')
        });
      } catch {}
    }

    /****************************************************************
     * Recorder wiring
     * - Host: full (Start/Stop/Play/Save/Load) + RECUI refresh
     * - Viewer: NO Start/Save; YES Stop/Play/Load (no RECUI)
     ****************************************************************/
    const $ = (id) => document.getElementById(id);
    const stage = document.getElementById('boardHost');

    if (role === 'host') {
      try {
        RECUI = await import('/src/recorder_ui.js');
        $('recStart')?.addEventListener('click', () => { FLXRec?.start?.(); setTimeout(()=>RECUI.refresh?.(), 50); });
        $('recStop') ?.addEventListener('click', () => { FLXRec?.stop?.();  RECUI.refresh?.(); });
        $('recPlay') ?.addEventListener('click', () => FLXRec?.play?.({ speed: 1.0, loop: false }));
        $('recSave') ?.addEventListener('click', () => FLXRec?.download?.('take.json'));
        $('recLoad') ?.addEventListener('change', async (e) => {
          const file = e.target.files?.[0]; if (!file) return;
          const text = await file.text();
          await FLXRec?.loadFromText?.(text);
          RECUI.refresh?.();
        });
      } catch {}
    } else {
      // Viewer: load minimal recorder for Load/Play/Stop only
      try {
        const { recorder: VRec } = await import('/src/recorder.js');
        $('recStop') ?.addEventListener('click', () => { VRec?.stop?.(); });
        $('recPlay') ?.addEventListener('click', () => VRec?.play?.({ speed: 1.0, loop: false }));
        $('recLoad') ?.addEventListener('change', async (e) => {
          const file = e.target.files?.[0]; if (!file) return;
          const text = await file.text();
          await VRec?.loadFromText?.(text);
        });
      } catch {}
    }

    /****************************************************************
     * Toolbar (both roles)
     ****************************************************************/
    $('fit')     ?.addEventListener('click',  () => stage.classList.remove('fill'));
    $('fill')    ?.addEventListener('click',  () => stage.classList.add('fill'));
    $('toggleBG')?.addEventListener('click',  () => document.body.classList.toggle('transparent'));

    /****************************************************************
     * Jog Physics (“Tape Mode”) — preserved from original
     ****************************************************************/
    const Jog = (() => {
      const CFG = { mode:'off', sensitivity:2.5, damping:0.92 };
      const S   = {
        L:{ angle:0, vel:0, lastVal:null, lastKey:null, el:null },
        R:{ angle:0, vel:0, lastVal:null, lastKey:null, el:null },
        anim:null
      };

      function toIdVariants(id){
        const v=String(id||''); const a=new Set([v]);
        if (v.includes('_x5F_')) a.add(v.replace(/_x5F_/g,'_'));
        if (v.includes('_'))     a.add(v.replace(/_/g,'_x5F_'));
        return [...a];
      }
      function getEl(id){
        for (const vid of toIdVariants(id)) {
          const el = document.getElementById(vid);
          if (el) return el;
        }
        return null;
      }
      function resolveJogEls(){ S.L.el=getEl('jog_L'); S.R.el=getEl('jog_R'); }
      resolveJogEls();

      function applyRotation(el, ang){
        if (!el) return;
        try {
          el.style.transformBox = 'fill-box';
          el.style.transformOrigin = 'center';
          el.style.transform = `rotate(${ang}deg)`;
        } catch {}
        try {
          const bb=el.getBBox(); const cx=bb.x+bb.width/2, cy=bb.y+bb.height/2;
          el.setAttribute('transform', `rotate(${ang} ${cx} ${cy})`);
        } catch {}
      }

      function tick(){
        S.anim = requestAnimationFrame(tick);
        if (CFG.mode !== 'tape') return;
        ['L','R'].forEach(side=>{
          const j=S[side]; if (!j.el) return;
          j.angle += j.vel;
          j.vel   *= CFG.damping;
          if (Math.abs(j.vel) < 0.001) j.vel = 0;
          applyRotation(j.el, j.angle);
        });
      }

      if (!window.__JOG_WRAP__) {
        window.__JOG_WRAP__ = true;
        const orig = window.consumeInfo;
        window.consumeInfo = (info) => { try { onEvent(info); } catch {} return orig(info); };
      }

      function onEvent(info){
        if (CFG.mode === 'off') return;

        const mm = getUnifiedMap?.() || [];
        const type = (info.type||'').toLowerCase();
        const code = type === 'cc' ? (info.controller ?? info.d1) : info.d1;
        const key  = `${type}:${info.ch}:${code}`;

        const hits = mm.filter(m =>
          (m.key && m.key === key && m.target) ||
          (!m.key && m.type === type && m.ch === info.ch && m.code === (info.controller ?? info.d1) && m.target)
        );

        let side = null;
        if (hits.some(h => (h.target||'').toLowerCase().includes('jog_l'))) side = 'L';
        if (hits.some(h => (h.target||'').toLowerCase().includes('jog_r'))) side = side || 'R';
        if (!side) return;

        const j = S[side]; if (!j.el) resolveJogEls();

        if (CFG.mode === 'absolute') {
          const angle = (info.value ?? info.d2 ?? 0) * (360/127);
          j.angle = angle; applyRotation(j.el, j.angle); return;
        }

        if (CFG.mode === 'tape') {
          const v = (info.value ?? info.d2 ?? 0) | 0;
          if (j.lastKey !== key) j.lastVal = null;
          let d;
          if (j.lastVal == null) d = 0;
          else {
            d = v - j.lastVal;
            if (d > 64) d -= 128;
            if (d < -64) d += 128;
          }
          j.lastVal = v; j.lastKey = key;
          j.vel += d * CFG.sensitivity;
          if (!S.anim) tick();
        }
      }

      function panel(){
        let el=document.getElementById('jogPanel'); if (el) return el;
        el=document.createElement('div');
        el.id='jogPanel';
        el.style.cssText=`
          position: fixed; right: 16px; bottom: 72px;
          width: min(360px, 92vw);
          background: var(--panel,#10162b); color: var(--ink,#cfe0ff);
          border: 1px solid var(--panel-border,#33406b); border-radius: 12px;
          box-shadow: 0 12px 30px rgba(0,0,0,.45);
          padding: 12px; z-index: 10001; display: none;`;
        el.innerHTML=`
          <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
            <strong>Jog Mode</strong><button id="jogClose">Close</button>
          </div>
          <div style="margin-top:10px;display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
            <label><input type="radio" name="jMode" value="off" checked> Off</label>
            <label><input type="radio" name="jMode" value="absolute"> Absolute</label>
            <label><input type="radio" name="jMode" value="tape"> Tape</label>
          </div>
          <div style="margin-top:10px;display:grid;gap:8px;">
            <label>Sensitivity (deg/step) <input type="range" id="jogSens" min="0.2" max="8" step="0.1" value="2.5"></label>
            <label>Damping (friction) <input type="range" id="jogDamp" min="0.80" max="0.99" step="0.005" value="0.92"></label>
          </div>`;
        document.body.appendChild(el);

        el.querySelector('#jogClose')?.addEventListener('click', ()=>hide());
        el.querySelectorAll('input[name="jMode"]').forEach(r=>{
          r.addEventListener('change', (e)=>{
            CFG.mode = e.target.value;
            if (CFG.mode!=='tape' && S.anim){ cancelAnimationFrame(S.anim); S.anim=null; }
          });
        });
        el.querySelector('#jogSens')?.addEventListener('input',(e)=>{ CFG.sensitivity=+e.target.value; });
        el.querySelector('#jogDamp')?.addEventListener('input',(e)=>{ CFG.damping=+e.target.value; });

        return el;
      }
      function show(){ panel().style.display='block'; }
      function hide(){ panel().style.display='none'; }
      function toggle(){ const el=panel(); el.style.display=(el.style.display==='none'||!el.style.display)?'block':'none'; }
      return { toggle, show, hide };
    })();

    /****************************************************************
     * Launcher
     * - Host: full menu (diagnostics/timeline/wizard/edit/theme + rec + jog + presets)
     * - Viewer: ONLY Theme + Fit/Fill/Toggle BG (no presets UI, no timeline)
     ****************************************************************/
    let launcherOk = false;
    try {
      const { initLauncher } = await import('/src/launcher.js');

      if (role === 'host') {
        const [DIAG, PRESETS, EDIT, WIZ] = await Promise.all([
          import('/src/diag.js'),
          import('/src/presets.js'),
          import('/src/editmode.js'),
          import('/src/wizard.js'),
        ]);

        initLauncher({
          actions: {
            // Panels
            toggleDiag:     () => DIAG.toggle(),
            toggleTimeline: () => import('/src/recorder_ui.js').then(m => m.toggle()),
            toggleWizard:   () => WIZ.toggle(),
            toggleEdit:     () => EDIT.toggle(),
            toggleTheme:    () => THEME.toggle(),
            toggleJog:      () => Jog.toggle(),
            // View
            fit:      () => stage.classList.remove('fill'),
            fill:     () => stage.classList.add('fill'),
            toggleBG: () => document.body.classList.toggle('transparent'),
            // Recorder
            recStart:  () => { FLXRec?.start?.(); setTimeout(()=>RECUI?.refresh?.(), 50); },
            recStop:   () => { FLXRec?.stop?.();  RECUI?.refresh?.(); },
            recPlay:   () =>  FLXRec?.play?.({ speed: 1.0, loop: false }),
            recSave:   () =>  FLXRec?.download?.('take.json'),
            recLoadText: async (text) => { await FLXRec?.loadFromText?.(text); RECUI?.refresh?.(); },
          },
          mountPresetUI: (el) => PRESETS.attachPresetUI(el),
        });
      } else {
        // Viewer: strict minimal menu
        initLauncher({
          actions: {
            toggleTheme: () => THEME.toggle(),
            fit:         () => stage.classList.remove('fill'),
            fill:        () => stage.classList.add('fill'),
            toggleBG:    () => document.body.classList.toggle('transparent'),
          },
          // no presets in viewer
          mountPresetUI: () => {},
        });
      }

      launcherOk = true;
    } catch (e) {
      console.warn('[launcher] missing or failed, falling back to basic menu', e);
    }

    /****************************************************************
     * Fallback floating “Menu” button (only if launcher failed)
     ****************************************************************/
    if (!launcherOk) {
      const menuBtn = document.createElement('button');
      menuBtn.textContent = 'Menu';
      menuBtn.id = 'fallbackMenu';
      menuBtn.style.cssText = 'position:fixed;right:16px;bottom:16px;z-index:10000';
      menuBtn.onclick = () => {
        const choices = (role === 'host')
          ? [
              ['Diagnostics', () => import('/src/diag.js').then(m=>m.toggle())],
              ['Timeline',    () => import('/src/recorder_ui.js').then(m=>m.toggle())],
              ['Wizard',      () => import('/src/wizard.js').then(m=>m.toggle())],
              ['Edit Mode',   () => import('/src/editmode.js').then(m=>m.toggle())],
              ['Theme',       () => THEME.toggle()],
              ['Jog Panel',   () => Jog.toggle()],
              ['Fit',         () => stage.classList.remove('fill')],
              ['Fill',        () => stage.classList.add('fill')],
              ['Toggle BG',   () => document.body.classList.toggle('transparent')],
            ]
          : [
              ['Theme',       () => THEME.toggle()],
              ['Fit',         () => stage.classList.remove('fill')],
              ['Fill',        () => stage.classList.add('fill')],
              ['Toggle BG',   () => document.body.classList.toggle('transparent')],
            ];

        const names = choices.map(([n]) => '• ' + n).join('\n');
        const picked = prompt('Available actions:\n' + names + '\n\nType the name exactly:');
        const found = choices.find(([n]) => n.toLowerCase() === String(picked||'').toLowerCase());
        if (found) found[1]();
      };
      document.body.appendChild(menuBtn);
    }

    /****************************************************************
     * Hotkeys
     ****************************************************************/
    document.addEventListener('keydown', (e)=>{
      if (e.shiftKey && e.key.toLowerCase()==='t') THEME.toggle(); // Theme
      if (e.shiftKey && e.key.toLowerCase()==='j') Jog.toggle();   // Jog panel
      if (role === 'host') {
        // host may add more hotkeys; viewer gets Theme/Jog only
      }
    });

    /****************************************************************
     * Debug helper
     ****************************************************************/
    window.FlashAll = () => (window.FLXTest?.smokeFlashAll?.({ delay: 50 }));
  </script>
</body>
</html>
