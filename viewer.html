<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FLX6 Visualizer — Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="/styles.css" />

  <!-- Hard-disable any corner popups if a stray import creeps back in -->
  <style>
    /* Nuke launcher & any legacy mini-menus */
    #fab, #fabSheet, .viewer-menu { display: none !important; }

    /* Minimal status bar */
    #statusBar {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 1000;
      display: inline-flex;
      gap: 10px;
      align-items: center;
      padding: 6px 10px;
      border-radius: 10px;
      background: rgba(16, 22, 43, 0.92);
      border: 1px solid var(--panel-border, #33406b);
      color: var(--ink, #cfe0ff);
      font: 13px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    #statusBar button {
      background: #0b1020;
      border: 1px solid #33406b;
      color: inherit;
      border-radius: 10px;
      padding: 6px 10px;
      cursor: pointer;
    }

    /* Stage sizing */
    #boardHost { width: 100vw; height: 100vh; }

    /* Optional: when .fill is on the stage, your stylesheet can make SVG cover */
    /* If your styles.css doesn’t include it, you can add rules like:
       #boardHost.fill svg { preserveAspectRatio: xMidYMid slice; }
       #boardHost:not(.fill) svg { preserveAspectRatio: xMidYMid meet; }
    */
  </style>

  <!-- Force your actual WS relay (override any guessing) -->
  <script>
    window.WS_URL = "wss://ws.setsoutofcontext.com";
    // window.WS_FORCE = true; // uncomment to forbid auto-guessing
  </script>
</head>
<body class="viewer">
  <!-- Board stage -->
  <div id="boardHost"></div>

  <!-- Minimal status bar (now with Fit/Fill/BG per your snippets) -->
  <div id="statusBar" role="status">
    <span id="wsStatus">WS: ⏳</span>
    <span id="midiStatus">MIDI: ⏳</span>
    <button id="fit" type="button" title="Fit SVG inside window">Fit</button>
    <button id="fill" type="button" title="Fill the frame">Fill</button>
    <button id="toggleBG" type="button" title="Toggle transparent background">Toggle BG</button>
    <button id="themeToggle" type="button" title="Toggle theme">Theme</button>
  </div>

  <!-- === Minimal inline module: init board, theme, statuses, designer, view controls === -->
  <script type="module">
    import { initBoard } from '/src/board.js';
    import * as THEME   from '/src/theme.js';

    // Role flags (kept for any downstream checks)
    const ROLE = 'viewer';
    document.body.classList.add(ROLE);
    document.body.dataset.role = ROLE;
    window.FLX_ROLE = ROLE;

    // Initialize SVG board
    await initBoard({ hostId: 'boardHost' });

    // Attach Theme Designer (your snippet)
    try {
      THEME.attachThemeDesigner?.({ svgRoot: document.querySelector('#boardHost svg') });
    } catch {}

    // Theme toggle
    document.getElementById('themeToggle')
      ?.addEventListener('click', () => THEME.toggle?.());

    // WS status hook for /src/bootstrap-viewer.js
    const wsStatusEl = document.getElementById('wsStatus');
    window.setWSStatus = (s) => { if (wsStatusEl) wsStatusEl.textContent = 'WS: ' + s; };

    // MIDI status (optional; will show "n/a" if no module)
    const midiStatusEl = document.getElementById('midiStatus');
    try {
      const midi = await import('/src/midi.js');
      midi.initMIDI?.({
        onStatus: (s) => { midiStatusEl.textContent = 'MIDI: ' + s; }
      });
    } catch {
      midiStatusEl.textContent = 'MIDI: n/a';
    }

    // Fit / Fill / Toggle BG buttons (your snippet)
    const stage = document.getElementById('boardHost');
    const fitBtn = document.getElementById('fit');
    const fillBtn = document.getElementById('fill');
    const bgBtn  = document.getElementById('toggleBG');

    if (fitBtn)  fitBtn.onclick  = () => stage.classList.remove('fill');
    if (fillBtn) fillBtn.onclick = () => stage.classList.add('fill');
    if (bgBtn)   bgBtn.onclick   = () => document.body.classList.toggle('transparent');

    // Jog Physics (“Tape Mode”) — full block preserved from OG
    const Jog = (() => {
      const CFG = { mode:'off', sensitivity:2.5, damping:0.92 };
      const S   = {
        L:{ angle:0, vel:0, lastVal:null, lastKey:null, el:null },
        R:{ angle:0, vel:0, lastVal:null, lastKey:null, el:null },
        anim:null
      };

      function toIdVariants(id){
        const v=String(id||''); const a=new Set([v]);
        if (v.includes('_x5F_')) a.add(v.replace(/_x5F_/g,'_'));
        if (v.includes('_'))     a.add(v.replace(/_/g,'_x5F_'));
        return [...a];
      }
      function getEl(id){
        for (const vid of toIdVariants(id)) {
          const el = document.getElementById(vid);
          if (el) return el;
        }
        return null;
      }
      function resolveJogEls(){ S.L.el=getEl('jog_L'); S.R.el=getEl('jog_R'); }
      resolveJogEls();

      function applyRotation(el, ang){
        if (!el) return;
        try {
          el.style.transformBox = 'fill-box';
          el.style.transformOrigin = 'center';
          el.style.transform = `rotate(${ang}deg)`;
        } catch {}
        try {
          const bb=el.getBBox(); const cx=bb.x+bb.width/2, cy=bb.y+bb.height/2;
          el.setAttribute('transform', `rotate(${ang} ${cx} ${cy})`);
        } catch {}
      }

      function tick(){
        S.anim = requestAnimationFrame(tick);
        if (CFG.mode !== 'tape') return;
        ['L','R'].forEach(side=>{
          const j=S[side]; if (!j.el) return;
          j.angle += j.vel;
          j.vel   *= CFG.damping;
          if (Math.abs(j.vel) < 0.001) j.vel = 0;
          applyRotation(j.el, j.angle);
        });
      }

      // Wrap consumeInfo once
      if (!window.__JOG_WRAP__) {
        window.__JOG_WRAP__ = true;
        const orig = window.consumeInfo || ((x)=>x);
        window.consumeInfo = (info) => { try { onEvent(info); } catch {} return orig(info); };
      }

      function onEvent(info){
        if (!info || CFG.mode === 'off') return;
        const mm = (window.getUnifiedMap?.() || []);
        const type = (info.type||'').toLowerCase();
        const code = type === 'cc' ? (info.controller ?? info.d1) : info.d1;
        const key  = `${type}:${info.ch}:${code}`;
        const hits = mm.filter(m =>
          (m.key && m.key === key && m.target) ||
          (!m.key && m.type === type && m.ch === info.ch && m.code === (info.controller ?? info.d1) && m.target)
        );

        let side = null;
        if (hits.some(h => (h.target||'').toLowerCase().includes('jog_l'))) side = 'L';
        if (hits.some(h => (h.target||'').toLowerCase().includes('jog_r'))) side = side || 'R';
        if (!side) return;

        const j = S[side];
        if (!j.el) resolveJogEls();

        if (CFG.mode === 'absolute') {
          const angle = (info.value ?? info.d2 ?? 0) * (360/127);
          j.angle = angle; applyRotation(j.el, j.angle); return;
        }
        if (CFG.mode === 'tape') {
          const v = (info.value ?? info.d2 ?? 0) | 0;
          if (j.lastKey !== key) j.lastVal = null;
          let d;
          if (j.lastVal == null) d = 0;
          else {
            d = v - j.lastVal;
            if (d > 64) d -= 128;
            if (d < -64) d += 128;
          }
          j.lastVal = v; j.lastKey = key;
          j.vel += d * 2.5;
          if (!S.anim) tick();
        }
      }

      // Expose a tiny runtime control if you want it in console:
      window.__JOG__ = {
        setMode: (m) => { CFG.mode = (m==='off'||m==='absolute'||m==='tape') ? m : 'off'; if (m!=='tape' && S.anim){ cancelAnimationFrame(S.anim); S.anim=null; } },
        get mode(){ return CFG.mode; }
      };
      return {};
    })();
  </script>

  <!-- WS bootstrap keeps ops/state handling (unchanged core behavior) -->
  <script type="module" src="/src/bootstrap-viewer.js"></script>

  <!-- Late-join fallback map loader (unchanged) -->
  <script>
    (function fallbackMapBootstrap(){
      const START = Date.now();
      const TRY_AFTER_MS = 1200;
      function hasMap() {
        try {
          if (Array.isArray(window.__currentMap) && window.__currentMap.length) return true;
          const cached = localStorage.getItem('learned_map');
          if (cached) {
            const m = JSON.parse(cached);
            if (Array.isArray(m) && m.length) { window.__currentMap = m; return true; }
          }
        } catch {}
        return false;
      }
      setTimeout(async () => {
        if (hasMap()) return; // map already applied by WS replay
        try {
          const r = await fetch('/learned_map.json', { cache: 'no-store' });
          if (!r.ok) return;
          const map = await r.json();
          if (Array.isArray(map) && map.length) {
            window.__currentMap = map;
            try { localStorage.setItem('learned_map', JSON.stringify(map)); } catch {}
            window.dispatchEvent(new CustomEvent('flx:remote-map', { detail: map }));
            console.log('[fallback-map] applied', map.length, 'entries after', Date.now()-START, 'ms');
          }
        } catch {}
      }, TRY_AFTER_MS);
    })();
  </script>
</body>
</html>
