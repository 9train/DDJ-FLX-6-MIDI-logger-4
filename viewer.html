<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FLX6 Visualizer — Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="./styles.css" />

  <!-- Viewer hard hide (CSS only, no module edits) -->
  <style>
    /* Recorder: hide host-only buttons in viewer */
    body.viewer #recStart,
    body.viewer #recSave { display: none !important; }

    /* Hide any host panels/menus/timelines if launcher renders them */
    body.viewer .panel,
    body.viewer [data-panel],
    body.viewer .wizard,
    body.viewer .diagnostics,
    body.viewer .timeline,
    body.viewer .edit-toolbar { display: none !important; }

    /* Common launchers: try to hide by structural hooks as well */
    body.viewer #launcher,
    body.viewer .launcher { /* keep the whole launcher hidden by default */
      display: none !important;
    }

    /* If your launcher must stay for Fit/Fill/Toggle BG, uncomment this
       and rely on the JS scrub below instead:
    body.viewer #launcher, body.viewer .launcher { display: block !important; }
    body.viewer #launcher .section-panels,
    body.viewer .launcher .section-panels,
    body.viewer #launcher .section-presets,
    body.viewer .launcher .section--presets { display: none !important; }
    body.viewer #launcher [data-action="toggleDiag"],
    body.viewer #launcher [data-action="toggleTimeline"],
    body.viewer #launcher [data-action="toggleWizard"],
    body.viewer #launcher [data-action="toggleEdit"] { display: none !important; }
    */
  </style>
</head>
<body class="viewer">
  <!-- Minimal toolbar for viewer -->
  <div id="ui">
    <div class="left" style="display:flex;gap:8px;align-items:center;">
      <button id="fit" title="Fit SVG inside window">Fit</button>
      <button id="fill" title="Fill the frame (good for OBS)">Fill</button>
      <button id="toggleBG" title="Toggle transparent background">Toggle BG</button>
    </div>
    <div class="right" style="display:flex;gap:10px;align-items:center;">
      <span id="wsStatus">WS: ⏳</span>
      <span id="midiStatus">MIDI: viewer</span>

      <!-- Viewer recorder controls (no Rec/Save) -->
      <button id="recStop"  title="Stop playback">Stop</button>
      <button id="recPlay"  title="Play loaded take">Play</button>
      <label id="recLoadWrap" style="display:inline-flex;align-items:center;gap:6px;">
        Load
        <input id="recLoad" type="file" accept="application/json" style="width:150px;" />
      </label>
    </div>
  </div>

  <!-- Stage for the SVG board -->
  <section id="boardHost" aria-label="Controller visual"></section>

  <!-- Default WS endpoint; roles.js can also auto-derive ws.* from visual.* -->
  <script>
    window.WS_URL = window.WS_URL || "wss://ws.setsoutofcontext.com";
  </script>

  <script type="module">
    /****************************************************************
     * Core imports (viewer-safe)
     ****************************************************************/
    import { initBoard, consumeInfo as boardConsume, getUnifiedMap } from '/src/board.js';
    import * as THEME from '/src/theme.js';
    import { connectWS } from '/src/ws.js';

    /****************************************************************
     * Force viewer role + WS URL resolution
     ****************************************************************/
    let role = 'viewer';
    let wsURL = window.WS_URL;

    try {
      const mod = await import('/src/roles.js');
      if (mod?.getWSURL) wsURL = mod.getWSURL();
    } catch {
      const qs = new URLSearchParams(location.search);
      if (!wsURL) {
        const host = location.hostname || 'localhost';
        wsURL = qs.get('ws') || `ws://${host}:` + (qs.get('wsport') || '8787');
      }
    }

    document.body.classList.add(role);
    document.body.dataset.role = role;
    window.FLX_ROLE = role;

    /****************************************************************
     * Init: board + Theme (Shift+T toggles Theme)
     ****************************************************************/
    await initBoard({ hostId: 'boardHost' });
    THEME.attachThemeDesigner({ svgRoot: document.querySelector('#boardHost svg') });

    /****************************************************************
     * Unified consumer (render into board)
     ****************************************************************/
    const baseConsume = (info) => boardConsume(info);
    window.consumeInfo = baseConsume;

    /****************************************************************
     * MINI NORMALIZER (SOP addition)
     * Normalizes incoming WS info shapes before rendering.
     * Mirrors your earlier "MIDI shape normalizer" without imports.
     ****************************************************************/
    function normalizeInfo(x) {
      if (!x || typeof x !== 'object') return x;

      // Unwrap wrapper types: { type:'midi_like'|'midi'|'info', payload:{...} }
      if (x.type && typeof x.payload === 'object') {
        const t = String(x.type).toLowerCase();
        if (t === 'midi_like' || t === 'midi' || t === 'info') {
          x = x.payload;
        }
      }

      const info = { ...x };
      const t = String(info.type || '').toLowerCase();

      // CC normalization
      if (t === 'cc') {
        const d1 = info.d1 ?? info.controller ?? 0;
        const d2 = info.d2 ?? info.value ?? 0;
        info.controller = d1;
        info.value = d2;
        info.d1 = d1;
        info.d2 = d2;
        info.type = 'cc';
        return info;
      }

      // Note on/off normalization (common in maps)
      if (t === 'noteon' || t === 'noteoff') {
        const d1 = info.d1 ?? info.note ?? 0;
        const d2 = info.d2 ?? info.vel ?? info.velocity ?? 0;
        info.note = d1;
        info.velocity = d2;
        info.d1 = d1;
        info.d2 = d2;
        info.type = t;
        return info;
      }

      // Pass-through other event types unchanged
      return info;
    }

    /****************************************************************
     * Status helpers
     ****************************************************************/
    const wsStatusEl = document.getElementById('wsStatus');
    const setWSStatus = (s) => { if (wsStatusEl) wsStatusEl.textContent = 'WS: ' + s; };

    /****************************************************************
     * WebSocket (viewer)
     * SOP CHANGE: onInfo now normalizes before consuming.
     ****************************************************************/
    const wsClient = connectWS({
      url: wsURL,
      role,
      onInfo: (info) => window.consumeInfo(normalizeInfo(info)), // <-- SOP change
      onStatus: (s) => setWSStatus(s),
    });
    window.wsClient = wsClient;

    /****************************************************************
     * Recorder: Load/Play/Stop only (viewer)
     ****************************************************************/
    const $ = (id) => document.getElementById(id);
    try {
      const { recorder: FLXRec } = await import('/src/recorder.js');
      window.recorder = FLXRec;

      $('recStop') ?.addEventListener('click', () => FLXRec.stop());
      $('recPlay') ?.addEventListener('click', () => FLXRec.play({ speed: 1.0, loop: false }));
      $('recLoad') ?.addEventListener('change', async (e) => {
        const file = e.target.files?.[0]; if (!file) return;
        const text = await file.text();
        await FLXRec.loadFromText(text);
      });
    } catch (e) {
      console.warn('[viewer] recorder unavailable', e);
    }

    /****************************************************************
     * Toolbar (viewer)
     ****************************************************************/
    const stage = document.getElementById('boardHost');
    $('fit')     ?.addEventListener('click',  () => stage.classList.remove('fill'));
    $('fill')    ?.addEventListener('click',  () => stage.classList.add('fill'));
    $('toggleBG')?.addEventListener('click',  () => document.body.classList.toggle('transparent'));

    /****************************************************************
     * Minimal launcher (viewer) + post-init scrub
     ****************************************************************/
    try {
      const { initLauncher } = await import('/src/launcher.js');
      const launcher = initLauncher({
        actions: {
          toggleTheme: () => THEME.toggle(),
          fit:         () => stage.classList.remove('fill'),
          fill:        () => stage.classList.add('fill'),
          toggleBG:    () => document.body.classList.toggle('transparent'),
        },
        mountPresetUI: () => {},
      });

      // Hard scrub any host leftovers if launcher still injected them
      const kill = (sel) => document.querySelectorAll(sel).forEach(el => el.remove());
      // common structural hooks
      kill('#launcher .section-panels, .launcher .section-panels');
      kill('#launcher .section--presets, .launcher .section--presets, #launcher .section-presets, .launcher .section-presets');
      // buttons by data-action (if present)
      kill('[data-action="toggleDiag"], [data-action="toggleTimeline"], [data-action="toggleWizard"], [data-action="toggleEdit"]');
      // any buttons that literally say Rec or Save (fallback)
      Array.from(document.querySelectorAll('#launcher button, .launcher button')).forEach(btn=>{
        const t = (btn.textContent || '').trim().toLowerCase();
        if (t === 'rec' || t === 'save') btn.remove();
      });
      // if a leftover header "Presets" exists, remove it
      Array.from(document.querySelectorAll('#launcher h2, .launcher h2')).forEach(h=>{
        if ((h.textContent||'').trim().toLowerCase()==='presets') h.remove();
      });
    } catch {}

    /****************************************************************
     * Jog Physics (“Tape Mode”) — preserved for viewer
     ****************************************************************/
    const Jog = (() => {
      const CFG = { mode:'off', sensitivity:2.5, damping:0.92 };
      const S   = {
        L:{ angle:0, vel:0, lastVal:null, lastKey:null, el:null },
        R:{ angle:0, vel:0, lastVal:null, lastKey:null, el:null },
        anim:null
      };

      function toIdVariants(id){
        const v=String(id||''); const a=new Set([v]);
        if (v.includes('_x5F_')) a.add(v.replace(/_x5F_/g,'_'));
        if (v.includes('_'))     a.add(v.replace(/_/g,'_x5F_'));
        return [...a];
      }
      function getEl(id){
        for (const vid of toIdVariants(id)) {
          const el = document.getElementById(vid);
          if (el) return el;
        }
        return null;
      }
      function resolveJogEls(){ S.L.el=getEl('jog_L'); S.R.el=getEl('jog_R'); }
      resolveJogEls();

      function applyRotation(el, ang){
        if (!el) return;
        try {
          el.style.transformBox = 'fill-box';
          el.style.transformOrigin = 'center';
          el.style.transform = `rotate(${ang}deg)`;
        } catch {}
        try {
          const bb=el.getBBox(); const cx=bb.x+bb.width/2, cy=bb.y+bb.height/2;
          el.setAttribute('transform', `rotate(${ang} ${cx} ${cy})`);
        } catch {}
      }

      function tick(){
        S.anim = requestAnimationFrame(tick);
        if (CFG.mode !== 'tape') return;
        ['L','R'].forEach(side=>{
          const j=S[side]; if (!j.el) return;
          j.angle += j.vel;
          j.vel   *= CFG.damping;
          if (Math.abs(j.vel) < 0.001) j.vel = 0;
          applyRotation(j.el, j.angle);
        });
      }

      if (!window.__JOG_WRAP__) {
        window.__JOG_WRAP__ = true;
        const orig = window.consumeInfo;
        window.consumeInfo = (info) => { try { onEvent(info); } catch {} return orig(info); };
      }

      function onEvent(info){
        if (CFG.mode === 'off') return;

        const mm = getUnifiedMap?.() || [];
        const type = (info.type||'').toLowerCase();
        const code = type === 'cc' ? (info.controller ?? info.d1) : info.d1;
        const key  = `${type}:${info.ch}:${code}`;

        const hits = mm.filter(m =>
          (m.key && m.key === key && m.target) ||
          (!m.key && m.type === type && m.ch === info.ch && m.code === (info.controller ?? info.d1) && m.target)
        );

        let side = null;
        if (hits.some(h => (h.target||'').toLowerCase().includes('jog_l'))) side = 'L';
        if (hits.some(h => (h.target||'').toLowerCase().includes('jog_r'))) side = side || 'R';
        if (!side) return;

        const j = S[side]; if (!j.el) resolveJogEls();

        if (CFG.mode === 'absolute') {
          const angle = (info.value ?? info.d2 ?? 0) * (360/127);
          j.angle = angle; applyRotation(j.el, j.angle); return;
        }

        if (CFG.mode === 'tape') {
          const v = (info.value ?? info.d2 ?? 0) | 0;
          if (j.lastKey !== key) j.lastVal = null;
          let d;
          if (j.lastVal == null) d = 0;
          else {
            d = v - j.lastVal;
            if (d > 64) d -= 128;
            if (d < -64) d += 128;
          }
          j.lastVal = v; j.lastKey = key;
          j.vel += d * 2.5;
          if (!S.anim) tick();
        }
      }

      return { };
    })();

    /****************************************************************
     * Hotkey: Theme
     ****************************************************************/
    document.addEventListener('keydown', (e)=>{
      if (e.shiftKey && e.key.toLowerCase()==='t') THEME.toggle();
    });
  </script>
</body>
</html>
